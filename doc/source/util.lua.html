<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>polycore</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="nowrap">
  <li><a href="../source/widget.lua.html">widget.lua</a></li>
  <li><a href="../source/data.lua.html">data.lua</a></li>
  <li><a href="../source/cairo_helpers.lua.html">cairo_helpers.lua</a></li>
  <li><strong>util.lua</strong></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/widget.html">widget</a></li>
  <li><a href="../modules/data.html">data</a></li>
  <li><a href="../modules/cairo_helpers.html">cairo_helpers</a></li>
  <li><a href="../modules/util.html">util</a></li>
</ul>

</div>

<div id="content">

    <h2>util.lua</h2>
<pre>
<span class="comment">--- Various helper functions
</span><span class="comment">-- @module util
</span>
<span class="keyword">local</span> util = {}

<span class="comment">--- Class creation
</span><span class="comment">-- @section class
</span>
<span class="comment">--- simple class creation helper
</span><a id="11"></a><span class="comment">-- @param parent parent class
</span><span class="keyword">function</span> util.class(parent)
    <span class="keyword">local</span> cls = <span class="global">setmetatable</span>({}, {
        __index = parent,
        __call = <span class="keyword">function</span> (cls, ...)
            <span class="keyword">local</span> instance = <span class="global">setmetatable</span>({}, cls)
            <span class="keyword">if</span> cls.init <span class="keyword">then</span>
                instance:init(...)
            <span class="keyword">end</span>
            <span class="keyword">return</span> instance
        <span class="keyword">end</span>,
    })
    cls.__index = cls
    <span class="keyword">return</span> cls
<span class="keyword">end</span>


<span class="comment">--- Memoization
</span><span class="comment">-- @section memo
</span>
<span class="keyword">local</span> memoization_clearers = {}

<span class="comment">--- Wrap a function to store its results for fast access via identical arguments.
</span><span class="comment">-- @tparam[opt] int delay number of updates that should pass before
</span><span class="comment">--                    data is cleared; use 0/false/nil to never clear
</span><span class="comment">-- @func fn function to be memoized; should only take stringable
</span><a id="37"></a><span class="comment">--                     arguments and return a non-nil value
</span><span class="keyword">function</span> util.memoize(delay, fn)
    <span class="keyword">if</span> fn == <span class="keyword">nil</span> <span class="keyword">then</span>
        delay, fn = <span class="number">0</span>, delay
    <span class="keyword">end</span>
    <span class="keyword">local</span> results = {}
    <span class="keyword">if</span> delay &gt; <span class="number">0</span> <span class="keyword">then</span>
        <span class="global">table</span>.insert(memoization_clearers, {delay, <span class="keyword">function</span>()
            results = {}
        <span class="keyword">end</span>})
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="keyword">function</span>(...)
        <span class="keyword">local</span> key = <span class="global">table</span>.concat({...}, <span class="string">":"</span>)
        <span class="keyword">if</span> results[key] == <span class="keyword">nil</span> <span class="keyword">then</span>
            results[key] = fn(...)
        <span class="keyword">end</span>
        <span class="keyword">return</span> results[key]
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- Clear outdated memoization data.
</span><span class="comment">-- Call this once per update cycle.
</span><span class="comment">-- @see util.memoize
</span><a id="60"></a><span class="comment">-- @int update_count conky's $update_count
</span><span class="keyword">function</span> util.reset_data(update_count)
    <span class="keyword">for</span> i = <span class="number">1</span>, #memoization_clearers <span class="keyword">do</span>
        <span class="keyword">if</span> update_count % memoization_clearers[i][<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">then</span>
            memoization_clearers[i][<span class="number">2</span>]()
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">--- Circular queue implementation.
</span><span class="comment">-- Adding new values causes old values to disappear.
</span><span class="comment">-- @type CycleQueue
</span><span class="keyword">local</span> CycleQueue = util.class()
util.CycleQueue = CycleQueue

<a id="76"></a><span class="comment">--- @int length fixed number of items to be stored
</span><span class="keyword">function</span> CycleQueue:init(length)
    self.length = length
    self.latest = length
    <span class="keyword">for</span> i = <span class="number">1</span>, length <span class="keyword">do</span>
        self[i] = <span class="number">0</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- Get the oldest value.
</span><a id="86"></a><span class="comment">-- @return oldest value
</span><span class="keyword">function</span> CycleQueue:head()
    <span class="keyword">return</span> self[self.latest % self.length + <span class="number">1</span>]
<span class="keyword">end</span>

<span class="comment">--- Add a value, causing the oldest value to disappear.
</span><a id="92"></a><span class="comment">-- @param item value to add
</span><span class="keyword">function</span> CycleQueue:put(item)
    self.latest = self.latest % self.length + <span class="number">1</span>
    self[self.latest] = item
<span class="keyword">end</span>

<span class="comment">--- Apply a function to each item in order from oldest to newest.
</span><a id="99"></a><span class="comment">-- @func fn
</span><span class="keyword">function</span> CycleQueue:each(fn)
    <span class="keyword">for</span> i = self.latest + <span class="number">1</span>, self.length <span class="keyword">do</span>
        fn(self[i], i - self.latest % self.length)
    <span class="keyword">end</span>
    <span class="keyword">for</span> i = <span class="number">1</span>, self.latest <span class="keyword">do</span>
        fn(self[i], i - self.latest + self.length)
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">--- General utility functions
</span><span class="comment">-- @section general
</span>
<span class="comment">--- Opposite of unpack/table.unpack
</span><a id="114"></a><span class="comment">-- DEPRECATED; use {...} instead
</span><span class="keyword">function</span> util.pack(...)
    <span class="keyword">return</span> {...}
<span class="keyword">end</span>

<span class="comment">--- Clamp a value between a minimum and a maximum
</span><span class="comment">-- @number min minimum value returned
</span><span class="comment">-- @number max maximum value returned
</span><span class="comment">-- @number val target value
</span><a id="123"></a><span class="comment">-- @treturn number
</span><span class="keyword">function</span> util.clamp(min, max, val)
    <span class="keyword">if</span> val &lt; min <span class="keyword">then</span> <span class="keyword">return</span> min <span class="keyword">end</span>
    <span class="keyword">if</span> val &gt; max <span class="keyword">then</span> <span class="keyword">return</span> max <span class="keyword">end</span>
    <span class="keyword">return</span> val
<span class="keyword">end</span>

<span class="comment">--- Call a function on each item of an iterator. Collect the results in a table.
</span><span class="comment">-- @func fn should take one argument and return one result
</span><span class="comment">-- @param iter iterator
</span><a id="133"></a><span class="comment">-- @treturn table list of results
</span><span class="keyword">function</span> util.map(fn, iter)
    <span class="keyword">local</span> arr = {}
    <span class="keyword">local</span> i = <span class="number">1</span>
    <span class="keyword">for</span> item <span class="keyword">in</span> iter <span class="keyword">do</span>
        arr[i] = fn(item)
        i = i + <span class="number">1</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> arr
<span class="keyword">end</span>

<span class="comment">--- Filter a table.
</span><span class="comment">-- @func fn should take one argument and return bool
</span><span class="comment">-- @tab arr
</span><a id="147"></a><span class="comment">-- @treturn table list of remaining entries
</span><span class="keyword">function</span> util.filter(fn, arr)
    <span class="keyword">local</span> result = {}
    <span class="keyword">local</span> k = <span class="number">1</span>
    <span class="keyword">for</span> i = <span class="number">1</span>, #arr <span class="keyword">do</span>
        <span class="keyword">if</span> fn(arr[i]) <span class="keyword">then</span>
            result[k] = arr[i]
            k = k + <span class="number">1</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> result
<span class="keyword">end</span>

<span class="comment">--- Turn a table of values into one value.
</span><span class="comment">-- @func fn should take two arguments and return one
</span><span class="comment">-- @param init starting value
</span><span class="comment">-- @tab arr values
</span><a id="164"></a><span class="comment">-- @return result
</span><span class="keyword">function</span> util.reduce(fn, init, arr)
    <span class="keyword">for</span> i = <span class="number">1</span>, #arr <span class="keyword">do</span>
        init = fn(init, arr[i])
    <span class="keyword">end</span>
    <span class="keyword">return</span> init
<span class="keyword">end</span>

<span class="comment">--- Generate a table of numbers from start to stop with step size step,
</span><span class="comment">-- like for i = start, stop, step do ...
</span><span class="comment">-- @number start
</span><span class="comment">-- @number stop
</span><span class="comment">-- @tparam ?number step (default: 1)
</span><a id="177"></a><span class="comment">-- @treturn {number,...}
</span><span class="keyword">function</span> util.range(start, stop, step)
    <span class="keyword">local</span> arr = {}
    <span class="keyword">local</span> i = <span class="number">1</span>
    <span class="keyword">for</span> value = start, stop, step <span class="keyword">or</span> <span class="number">1</span> <span class="keyword">do</span>
        arr[i] = value
        i = i + <span class="number">1</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> arr
<span class="keyword">end</span>

<span class="comment">--- Calculate the average of a table of numbers.
</span><span class="comment">-- @tparam {number,...} arr
</span><a id="190"></a><span class="comment">-- @treturn number
</span><span class="keyword">function</span> util.avg(arr)
    <span class="keyword">local</span> acc = <span class="number">0</span>
    <span class="keyword">for</span> i = <span class="number">1</span>, #arr <span class="keyword">do</span>
        acc = acc + arr[i]
    <span class="keyword">end</span>
    <span class="keyword">return</span> acc / #arr
<span class="keyword">end</span>

<span class="comment">--- Shuffle a table in-place using Fisher-Yates shuffle.
</span><a id="200"></a><span class="comment">-- @tab array
</span><span class="keyword">function</span> util.shuffle(array)
    <span class="keyword">for</span> counter = #array, <span class="number">2</span>, -<span class="number">1</span> <span class="keyword">do</span>
        <span class="keyword">local</span> index = <span class="global">math</span>.random(counter)
        array[index], array[counter] = array[counter], array[index]
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">return</span> util</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2019-11-01 17:47:03 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
